\documentclass{beamer}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}

% Beamer settings for table of contents
\setbeamertemplate{section in toc}[sections numbered]
\setbeamertemplate{subsection in toc}[subsections numbered]
\setbeamertemplate{section in toc shaded}[default][50]
\setbeamertemplate{subsection in toc shaded}[default][50]

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{Nust: A Statically-Typed, Reference-Safe Programming Language}
\author{David Tran}
\date{\today}

\begin{document}

\frame{\titlepage}

\section{Introduction}
\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\begin{frame}
\frametitle{Overview}
\begin{itemize}
    \item Nust is a statically-typed, reference-safe programming language
    \item Four main components:
    \begin{itemize}
        \item Parser
        \item Type Checker
        \item Compile
        \item Virtual Machine
    \end{itemize}
    \item Each component has specific responsibilities and implementation details
\end{itemize}
\end{frame}

\begin{frame}{Design Goals \& Scope}
    \begin{itemize}
      \item \textbf{Parsing}: Implement a recursive descent parser to transform source code into an Abstract Syntax Tree (AST).
      \item \textbf{Type Checking}: Statically check the AST for type correctness, enforcing mutability and borrowing rules (annotate AST nodes with types or report errors).
      \item \textbf{Compilation}: Design and implement a compiler backend that translates the typed AST into bytecode for the stack-based Nust VM (NVM).
      \item \textbf{Virtual Machine}: Develop a stack-based virtual machine to execute the generated bytecode (manage stack frames, instruction execution).
    \end{itemize}
  \end{frame}

\section{Language Design}
\begin{frame}[fragile]
\frametitle{Language Grammar (1/4)}
\begin{lstlisting}[language=bnf,basicstyle=\tiny]
<program>      ::= <item_list>

<item_list>    ::= <item> <item_list>
                | ε

<item>         ::= <function_decl>
                | <stmt>

<function_decl> ::= "fn" <ident> "(" <param_list_opt> ")" "{" <stmt_list> "}"

<param_list_opt> ::= <param_list>
                   | ε

<param_list>   ::= <param> "," <param_list>
                 | <param>

<param>        ::= <mut_opt> <ident> ":" <type>
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Language Grammar (2/4)}
\begin{lstlisting}[language=bnf,basicstyle=\tiny]
<stmt_list>    ::= <stmt> <stmt_list>
                 | ε

<stmt>         ::= <let_stmt> ";"
                 | <expr_stmt> ";"
                 | <if_stmt>
                 | <while_stmt>
                 | <block>
                 | <return_stmt> ";"

<block>        ::= "{" <stmt_list> "}"

<let_stmt>     ::= "let" <mut_opt> <ident> ":" <type> "=" <expr>

<expr_stmt>    ::= <expr>

<if_stmt>      ::= "if" "(" <expr> ")" <block> <else_clause_opt>

<else_clause_opt> ::= "else" <block>
                    | ε

<while_stmt>   ::= "while" "(" <expr> ")" <block>

<return_stmt>  ::= "return" <expr_opt>

<expr_opt>     ::= <expr>
                 | ε
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Language Grammar (3/4)}
\begin{lstlisting}[language=bnf,basicstyle=\tiny]
<expr>         ::= <literal>
                | <ident>
                | <expr> <binop> <expr>
                | <unop> <expr>
                | <expr> "(" <arg_list_opt> ")"         // function call
                | "&" <expr>                            // immutable borrow
                | "&mut" <expr>                         // mutable borrow
                | "(" <expr> ")"                        // grouping
                | <ident> "=" <expr>                    // assignment

<arg_list_opt> ::= <arg_list>
                 | ε

<arg_list>     ::= <expr> "," <arg_list>
                 | <expr>

<binop>        ::= "+" | "-" | "*" | "/" 
                | "==" | "!=" | "<" | ">" | "<=" | ">="
                | "&&" | "||"  // logical AND and OR

<unop>         ::= "-" | "!"

<mut_opt>      ::= "mut"
                 | ε
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Language Grammar (4/4)}
\begin{lstlisting}[language=bnf,basicstyle=\tiny]
<literal>      ::= <int_lit> | <bool_lit> | <string_lit>

<int_lit>      ::= [0-9]+

<bool_lit>     ::= "true" | "false"

<string_lit>   ::= "\"" <string_char>* "\""

<string_char>  ::= any character except `"` or `\`
                | "\\" <escaped_char>

<escaped_char> ::= "\"" | "\\" | "n" | "t" | "r"

<type>         ::= "i32"
                | "bool"
                | "str"
                | "&" <type>              // immutable reference
                | "&mut" <type>           // mutable reference

<ident>        ::= [a-zA-Z_][a-zA-Z0-9_]*
\end{lstlisting}
\end{frame}

\section{Implementation}
\subsection{Parser}
\begin{frame}
\frametitle{Parser}
\begin{itemize}
    \item Converts source code into Abstract Syntax Tree (AST)
    \item Handwritten recursive descent parser
    \item Key features:
    \begin{itemize}
        \item Position tracking for error reporting
        \item Scope management
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Parser Implementation}
\begin{lstlisting}[language=C++]
class Scope {
public:
    std::weak_ptr<Scope> parent;
    std::vector<std::string> declarations;  // Variables declared in this scope
    
    explicit Scope(std::weak_ptr<Scope> parent = {}) : parent(parent) {}
};

class Parser {
    // Scope management
    std::shared_ptr<Scope> current_scope;
    std::shared_ptr<Scope> enter_scope();
    void exit_scope();
    
    // Parsing functions
    std::unique_ptr<FunctionDecl> parse_function();
    std::unique_ptr<Stmt> parse_statement();
    std::unique_ptr<Expr> parse_expr();
    // ...
};
\end{lstlisting}
\end{frame}

\subsection{Type Checker}
\begin{frame}
\frametitle{Type Checker}
\begin{itemize}
    \item Ensures type safety and performs semantic analysis
    \item Key features:
    \begin{itemize}
        \item Static type checking
        \item Reference safety checks
        \item Mutability tracking
        \item Function signature validation
    \end{itemize}
    \item Uses symbol table for variable tracking
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Type Checker Implementation}
\begin{lstlisting}[language=C++,basicstyle={\tiny}]
class TypeChecker {
    // Scope management
    struct VariableInfo {
        std::unique_ptr<Type> type;
        bool is_mut;
    };
    
    std::vector<std::unordered_map<std::string, VariableInfo>> scopes_;
    
    // Borrow checking
    bool is_assignable(const Type& target, const Type& source) {
        if (target.kind == source.kind) {
            if (target.kind == Type::Kind::Ref || 
                target.kind == Type::Kind::MutRef) {
                return is_assignable(*target.base_type, *source.base_type);
            }
            return true;
        }
        // Allow implicit conversion from &mut T to &T
        if (target.kind == Type::Kind::Ref && 
            source.kind == Type::Kind::MutRef) {
            return is_assignable(*target.base_type, *source.base_type);
        }
        return false;
    }
};
\end{lstlisting}
\end{frame}

\subsection{Compiler}
\begin{frame}
\frametitle{Compiler}
\begin{itemize}
    \item Transforms AST into bytecode instructions
    \item Three-pass compilation:
    \begin{itemize}
        \item Find main function
        \item Build function table
        \item Generate bytecode
    \end{itemize}
    \item Handles local variables and control flow
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Compiler Implementation}
\begin{lstlisting}[language=C++]
class Compiler {
    std::vector<Instruction> instructions;
    FunctionTable function_table;
    std::unordered_map<std::string, size_t> local_vars;
    
    void compile_function(const FunctionDecl* func);
    void compile_statement(const Stmt* stmt);
    void compile_expression(const Expr* expr);
    // ...
};
\end{lstlisting}
\end{frame}

\subsection{Virtual Machine}
\begin{frame}
\frametitle{Virtual Machine}
\begin{itemize}
    \item Executes compiled bytecode
    \item Stack-based execution model
    \item Key features:
    \begin{itemize}
        \item Function call stack
        \item Reference management
        \item Memory safety
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{VM Implementation}
\begin{lstlisting}[language=C++]
class VirtualMachine {
    std::vector<Value> stack_;
    std::vector<Value> memory_;
    size_t pc_ = 0;
    size_t fp_ = 0;
    
    void execute_instruction(const Instruction& instr);
    void handle_call(size_t operand);
    void handle_ret();
    // ...
};
\end{lstlisting}
\end{frame}

\section{Bytecode and Runtime}
\begin{frame}
\frametitle{Bytecode Format}
\begin{itemize}
    \item Stack-based instruction set
    \item Value Types:
    \begin{itemize}
        \item \texttt{i32}: 32-bit signed integer
        \item \texttt{bool}: Boolean value
        \item \texttt{str}: String reference
        \item \texttt{ref}: Reference to a value
        \item \texttt{mut\_ref}: Mutable reference
        \item \texttt{fn}: Function reference
    \end{itemize}
    \item Stack Frame Layout:
    \begin{itemize}
        \item Return Address
        \item Frame Pointer
        \item Local Variables
        \item Arguments
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Instruction Categories}
\begin{itemize}
    \item Stack Operations
    \begin{itemize}
        \item \texttt{PUSH\_I32}, \texttt{PUSH\_BOOL}, \texttt{PUSH\_STR}
        \item \texttt{POP}
    \end{itemize}
    \item Variable Operations
    \begin{itemize}
        \item \texttt{LOAD}, \texttt{STORE}
        \item \texttt{LOAD\_REF}, \texttt{STORE\_REF}
    \end{itemize}
    \item Control Flow
    \begin{itemize}
        \item \texttt{JMP}, \texttt{JMP\_IF}, \texttt{JMP\_IF\_NOT}
        \item \texttt{CALL}, \texttt{RET}, \texttt{RET\_VAL}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Instruction Categories}
\begin{itemize}
    \item Reference Management
    \begin{itemize}
        \item \texttt{BORROW}: Create immutable reference
        \item \texttt{BORROW\_MUT}: Create mutable reference
        \item \texttt{DEREF}: Access referenced value
        \item \texttt{DEREF\_MUT}: Access mutable reference
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Function Calls}
\begin{itemize}
    \item Call Process:
    \begin{itemize}
        \item Arguments pushed in reverse order
        \item Return address and frame pointer saved
        \item New stack frame created
        \item Control transferred to callee
    \end{itemize}
    \item Return Process:
    \begin{itemize}
        \item Return value (if any) saved
        \item Stack frame restored
        \item Control returns to caller
    \end{itemize}
\end{itemize}
\end{frame}

\section{Demo}
\begin{frame}
\frametitle{Demo}
\begin{itemize}
    \item Test Suite:
    \begin{itemize}
        \item Parser tests
        \item Type checker tests
        \item Compiler tests
        \item VM tests
        \item Integration tests
    \end{itemize}
    \item Example Programs:
    \begin{itemize}
        \item Function calls and returns
        \item Reference safety
        \item Control flow
        \item Arithmetic operations
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Outcome}
\begin{itemize}
    \item Successfully implemented a statically-typed, reference-safe programming language
    \item Some bugs still present
    \item Future work possibilities
    \begin{itemize}
        \item Dynamically allocated functor objects
        \item Collection types
        \item Metaprogramming
    \end{itemize}
\end{itemize}
\end{frame}

\end{document} 